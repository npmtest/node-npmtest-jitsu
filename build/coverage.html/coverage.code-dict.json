{"/home/travis/build/npmtest/node-npmtest-jitsu/test.js":"/* istanbul instrument in package npmtest_jitsu */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jitsu/lib.npmtest_jitsu.js":"/* istanbul instrument in package npmtest_jitsu */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jitsu = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jitsu = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jitsu/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jitsu && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jitsu */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jitsu\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jitsu.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jitsu.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jitsu.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jitsu.__dirname + '/lib.npmtest_jitsu.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu.js":"/*\n * jitsu.js: Top-level include for the jitsu module.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar path = require('path'),\n    util = require('util'),\n    colors = require('colors'),\n    flatiron = require('flatiron')\n    godaddy = require('./jitsu/commands/godaddy');\n\nvar jitsu = module.exports = flatiron.app;\n\n//\n// Setup `jitsu` to use `pkginfo` to expose version\n//\nrequire('pkginfo')(module, 'name', 'version');\n\n//\n// Configure jitsu to use `flatiron.plugins.cli`\n//\njitsu.use(flatiron.plugins.cli, {\n  version: true,\n  usage: require('./jitsu/usage'),\n  source: path.join(__dirname, 'jitsu', 'commands'),\n  argv: {\n    version: {\n      alias: 'v',\n      description: 'print jitsu version and exit',\n      string: true\n    },\n    localconf: {\n      description: 'search for .jitsuconf file in ./ and then parent directories',\n      string: true\n    },\n    jitsuconf: {\n      alias: 'j',\n      description: 'specify file to load configuration from',\n      string: true\n    },\n    noanalyze: {\n      description: 'skip require-analyzer: do not attempt to dynamically detect dependencies',\n      boolean: true\n    },\n    colors: {\n      description: '--no-colors will disable output coloring',\n      default: true,\n      boolean: true\n    },\n    confirm: {\n      alias: 'c',\n      description: 'prevents jitsu from asking before overwriting/removing things',\n      default: false,\n      boolean: true\n    },\n    release: {\n      alias: 'r',\n      description: 'specify release version number or semantic increment (build, patch, minor, major)',\n      string: true\n    },\n    raw: {\n      description: 'jitsu will only output line-delimited raw JSON (useful for piping)',\n      boolean: true\n    }\n  }\n});\n\njitsu.options.log = {\n  console: {\n    raw: jitsu.argv.raw\n  }\n};\n\n//\n// Setup config, users, command aliases and prompt settings\n//\njitsu.prompt.properties = flatiron.common.mixin(\n  jitsu.prompt.properties,\n  require('./jitsu/properties')\n);\njitsu.prompt.override   = jitsu.argv;\nrequire('./jitsu/config');\nrequire('./jitsu/alias');\nrequire('./jitsu/commands');\n\n//\n// Setup other jitsu settings.\n//\njitsu.started  = false;\njitsu.common   = require('./jitsu/common');\njitsu.package  = require('./jitsu/package');\njitsu.logFile  = new (require('./jitsu/common/logfile').LogFile)(path.join(process.env.HOME, '.jitsulog'));\n\n//\n// Hoist `jitsu.api` from `nodejitsu-api` module.\n//\njitsu.api               = {};\njitsu.api.Client        = require('nodejitsu-api').Client;\njitsu.api.Apps          = require('nodejitsu-api').Apps;\njitsu.api.Databases     = require('nodejitsu-api').Databases;\njitsu.api.Logs          = require('nodejitsu-api').Logs;\njitsu.api.Snapshots     = require('nodejitsu-api').Snapshots;\njitsu.api.Users         = require('nodejitsu-api').Users;\njitsu.api.Tokens        = require('nodejitsu-api').Tokens;\n\n//\n// ### function welcome ()\n// Print welcome message.\n//\njitsu.welcome = function () {\n  //\n  // If a user is logged in, show username\n  //\n  var username = jitsu.config.get('username') || '';\n\n  godaddy.notice(jitsu);\n\n  jitsu.log.info('Welcome to ' + 'Nodejitsu'.grey + ' ' + username.magenta);\n  jitsu.log.info('jitsu v' + jitsu.version + ', node ' + process.version);\n  jitsu.log.info('It worked if it ends with ' + 'Nodejitsu'.grey + ' ok'.green.bold);\n\n};\n\n//\n// ### function start (command, callback)\n// #### @command {string} Command to execute once started\n// #### @callback {function} Continuation to pass control to when complete.\n// Starts the jitsu CLI and runs the specified command.\n//\njitsu.start = function (callback) {\n  //\n  // Check for --no-colors/--colors option, without hitting the config file\n  // yet\n  //\n  var useColors = (typeof jitsu.argv.colors == 'undefined' || jitsu.argv.colors);\n\n  useColors || (colors.mode = \"none\");\n\n  //\n  // whoami command should not output anything but username\n  //\n  if (jitsu.argv._[0] === \"whoami\") {\n    console.log(jitsu.config.get('username') || '');\n    return;\n  }\n\n  jitsu.init(function (err) {\n    if (err) {\n      jitsu.welcome();\n      jitsu.showError(jitsu.argv._.join(' '), err);\n      return callback(err);\n    }\n\n    jitsu.common.checkVersion(function (err) {\n      if (err) {\n        return callback();\n      }\n\n      var minor, username;\n\n      //\n      // --no-colors option turns off output coloring, and so does setting\n      // colors: false in ~/.jitsuconf (see\n      // https://github.com/nodejitsu/jitsu/issues/101 )\n      //\n      if ( !jitsu.config.get('colors') || !useColors ) {\n        colors.mode = \"none\";\n        jitsu.log.get('default').stripColors = true;\n        jitsu.log.get('default').transports.console.colorize = false;\n      }\n\n      jitsu.welcome();\n\n      minor = process.version.split('.')[1];\n\n      if (parseInt(minor, 10) % 2) {\n        jitsu.log.warn('You are using unstable version of node.js. You may experience problems.');\n      }\n\n      username = jitsu.config.get('username');\n      if (!username && jitsu.config.get('requiresAuth').indexOf(jitsu.argv._[0]) !== -1) {\n        return jitsu.commands.users.login(function (err) {\n          if (err) {\n            jitsu.showError(jitsu.argv._.join(' '), err);\n            return callback(err);\n          }\n\n          var username = jitsu.config.get('username');\n          jitsu.log.info('Successfully configured user ' + username.magenta);\n          return jitsu.exec(jitsu.argv._, callback);\n        });\n      }\n      return jitsu.exec(jitsu.argv._, callback);\n    });\n  });\n};\n\n//\n// ### function exec (command, callback)\n// #### @command {string} Command to execute\n// #### @callback {function} Continuation to pass control to when complete.\n// Runs the specified command in the jitsu CLI.\n//\njitsu.exec = function (command, callback) {\n  function execCommand (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    //\n    // Remark: This is a temporary fix for aliasing init=>install,\n    // was having a few issues with the alias command on the install resource\n    //\n    if (command[0] === 'init') {\n      command[0] = 'install';\n    }\n\n    // Alias db to databases\n    if (command[0] === 'db' || command[0] === 'dbs' || command[0] === 'database') {\n      command[0] = 'databases';\n    }\n\n    // Allow `jitsu logs` as a shortcut for `jitsu logs app`\n    if (command[0] === 'logs' && command.length === 1) {\n      command[1] = 'app';\n    }\n\n    // Allow `jitsu host` as a shortcut for `jitsu config set remoteHost`\n    if (command[0] === 'host' && command.length === 2) {\n      command[3] = command[1];\n      command[0] = 'config';\n      command[1] = 'set';\n      command[2] = 'remoteHost';\n    }\n\n    //\n    // Prevent sign-ups on our alias as well as on the regular route.\n    //\n    if (command[0] === 'signup' || command[0] === 'users' && command[1] === 'create') {\n      godaddy.disabled(jitsu, command.join(' '));\n      return callback(new Error('Signup is disabled'));\n    }\n\n    jitsu.log.info('Executing command ' + command.join(' ').magenta);\n    jitsu.router.dispatch('on', command.join(' '), jitsu.log, function (err, shallow) {\n      if (err) {\n        jitsu.showError(command.join(' '), err, shallow);\n        return callback(err);\n      }\n\n      //\n      // TODO (indexzero): Something here\n      //\n      callback();\n    });\n  }\n\n  return !jitsu.started ? jitsu.setup(execCommand) : execCommand();\n};\n\n//\n// ### function setup (callback)\n// #### @callback {function} Continuation to pass control to when complete.\n// Sets up the instances of the Resource clients for jitsu.\n// there is no io here, yet this function is ASYNC.\n//\njitsu.setup = function (callback) {\n  if (jitsu.started === true) {\n    return callback();\n  }\n\n  var rejectUnauthorized = jitsu.config.get('rejectUnauthorized');\n  if (typeof rejectUnauthorized === 'undefined') {\n    jitsu.config.set('rejectUnauthorized', false);\n  }\n\n  var userAgent = jitsu.config.get('headers:user-agent');\n  if (!userAgent) {\n    jitsu.config.set('headers:user-agent', 'jitsu/' + jitsu.version);\n  }\n\n  ['Users', 'Apps', 'Snapshots', 'Databases', 'Logs', 'Tokens'].forEach(function (key) {\n    var k = key.toLowerCase();\n    jitsu[k] = new jitsu.api[key](jitsu.config);\n    jitsu[k].on('debug::request',  debug);\n    jitsu[k].on('debug::response', debug);\n    function debug (data) {\n      if (jitsu.argv.debug || jitsu.config.get('debug')) {\n        if (data.headers && data.headers['Authorization']) {\n          data = JSON.parse(JSON.stringify(data));\n          data.headers['Authorization'] = Array(data.headers['Authorization'].length).join('*');\n        }\n\n        util.inspect(data, false, null, true).split('\\n').forEach(jitsu.log.debug);\n      }\n    };\n  });\n\n  jitsu.started = true;\n  callback();\n};\n\n//\n// ### function showError (command, err, shallow, skip)\n// #### @command {string} Command which has errored.\n// #### @err {Error} Error received for the command.\n// #### @shallow {boolean} Value indicating if a deep stack should be displayed\n// #### @skip {boolean} Value indicating if this error should be forcibly suppressed.\n// Displays the `err` to the user for the `command` supplied.\n//\njitsu.showError = function (command, err, shallow, skip) {\n  var username,\n      display,\n      errors,\n      stack;\n\n  //\n  // ### function unknownError(message, stack)\n  // Displays an unknown error by dumping the call `stack`\n  // and a given `message`.\n  //\n  function unknownError(message, stack) {\n    jitsu.log.error(message);\n    stack.split('\\n').forEach(function (line) {\n      jitsu.log.error(line);\n    })\n  }\n\n  //\n  // ### function solenoidError(display)\n  // Displays a \"solenoid\" error.\n  //\n  function solenoidError(display) {\n    jitsu.log.error('Error starting application. This could be a user error.');\n    display.solenoid.split('\\n').forEach(function (line) {\n      jitsu.log.error(line);\n    });\n  }\n\n  //\n  // ### function appError(display)\n  // Displays an \"application\" error.\n  //\n  function appError(display) {\n    if (display.output) {\n      jitsu.log.error('Error output from application. This is usually a user error.');\n      display.output.split('\\n').forEach(function (line) {\n        jitsu.log.error(line);\n      })\n    }\n\n    return !display.solenoid\n      ? unknownError(display.message, display.stack)\n      : solenoidError(display);\n  }\n\n  if (err.statusCode === 403) {\n    //jitsu.log.error('403 ' + err.result.error);\n  }\n  else if (err.statusCode === 503) {\n    if (err.result && err.result.message) {\n      jitsu.log.error(err.result.message);\n    }\n    else {\n      jitsu.log.error('The Nodejitsu cloud is currently at capacity.  Please try again later.');\n    }\n  }\n  else if (!skip) {\n    jitsu.log.error('Error running command ' + command.magenta);\n    if (!jitsu.config.get('nolog')) {\n      jitsu.logFile.log(err);\n    }\n\n    if (err.result) {\n      if (err.result.message) {\n        jitsu.log.error(err.result.message);\n      }\n\n      if (err.result.error && typeof err.result.error == 'string') {\n        if (~err.result.error.indexOf('matching versions')) {\n          jitsu.log.error(err.result.error);\n          jitsu.log.error(\"Do not use a specific engine version, try a generic one (eg: 0.8.x or 0.10.x)\");\n        } else {\n          jitsu.log.error(err.result.error);\n        }\n      }\n\n      if (err.result.errors && Array.isArray(err.result.errors)) {\n        errors = {\n          connection: err.result.errors.filter(function (err) {\n            return err.blame === 'connection';\n          }),\n          application: err.result.errors.filter(function (err) {\n            return err.blame === 'application';\n          }),\n          solenoid: err.result.errors.filter(function (err) {\n            return err.blame === 'solenoid';\n          })\n        };\n\n        if (errors.application.length) {\n          return appError(errors.application[0]);\n        }\n        else if (errors.solenoid.length) {\n          return solenoidError(errors.solenoid[0])\n        }\n\n        return errors.connection.length\n          ? unknownError('Error contacting drone(s):', errors.connection[0].stack)\n          : unknownError('Error returned from Nodejitsu:', err.result.errors[0].stack);\n      }\n      else if (err.result.stack) {\n        return unknownError('Error returned from Nodejitsu:', err.result.stack);\n      }\n    }\n    else {\n      if (err.stack && !shallow) {\n        if (err.message && err.message === 'socket hang up' && err.code && err.code === 'ECONNRESET') {\n          jitsu.log.info('The nodejitsu api reset the connection');\n          jitsu.log.help('This error may be due to the application or the drone server');\n        } else if (err.message && err.message === 'ETIMEDOUT'){\n          jitsu.log.info(\n            'jitsu\\'s client request timed out before the server ' +\n            'could respond. Please increase your client timeout');\n          jitsu.log.help('(Example: `jitsu config set timeout 480000`)');\n          jitsu.log.help('This error may be due to network connection problems');\n        } else {\n          err.stack.split('\\n').forEach(function (trace) {\n            jitsu.log.error(trace);\n          });\n        }\n\n        return;\n      }\n    }\n\n    if (err.message) {\n      jitsu.log.error(err.message);\n    }\n  }\n\n  jitsu.log.help(\"For help with this error contact Nodejitsu Support:\");\n  jitsu.log.help(\"  webchat: <http://webchat.nodejitsu.com/>\");\n  jitsu.log.help(\"      irc: <irc://chat.freenode.net/#nodejitsu>\");\n  jitsu.log.help(\"    email: <support@nodejitsu.com>\");\n  jitsu.log.help(\"\");\n  jitsu.log.help(\"  Copy and paste this output to a gist (http://gist.github.com/)\");\n  jitsu.log.info('Nodejitsu '.grey + 'not ok'.red.bold);\n};\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/commands/godaddy.js":"'use strict';\n\n/*\n * godaddy.js: Output the details about our GoDaddy acquisition\n *\n *\n * (C) 2015, Nodejitsu Inc.\n *\n */\n\nvar godaddy = module.exports = function go(callback) {\n  var jitsu = this;\n\n  jitsu.log.help();\n  jitsu.log.help('We are excited to join GoDaddy to help spearhead their largest Node.js product:');\n  jitsu.log.help('Website Builder. As a part of this Nodejitsu will help existing customers');\n  jitsu.log.help('transition onto new solutions for their hosting needs until early August 2015.');\n  jitsu.log.help('Be sure you have migrated your applications off of Nodejitsu before the end of');\n  jitsu.log.help('the transition period or you may encounter permenant data loss.');\n  jitsu.log.help();\n  jitsu.log.help('I am an existing Nodejitsu customer. What does this mean for me?');\n  jitsu.log.help();\n  jitsu.log.help('As an operations company, we know that our services are critical to the');\n  jitsu.log.help('operation of our customersâ€™ businesses. Because of this, we are doing two');\n  jitsu.log.help('things:');\n  jitsu.log.help();\n  jitsu.log.help('1. Continuing to operate all of our products for seven months to ensure everyone');\n  jitsu.log.help('   has adequate time for any and all changes related to the transition.');\n  jitsu.log.help('2. Devoting the necessary support resources during the transition period to ensure');\n  jitsu.log.help('   all of our customers can have their questions answered.');\n  jitsu.log.help();\n  jitsu.log.help('Read more at:  ' + 'https://nodejitsu.com/godaddy'.bold.green);\n  jitsu.log.help('Press release: ' + 'https://www.nodejitsu.com/company/press/2015/02/10/nodejitsu-joins-godaddy/'.bold.green);\n  jitsu.log.help();\n  jitsu.log.info('Nodejitsu'.grey + ' ok'.green.bold);\n};\n\ngodaddy.usage = [\n  'Learn what the godaddy acquisitions means for you',\n  '',\n  'jitsu godaddy',\n];\n\n//\n// The shutdown date of all the things.\n//\ngodaddy.shutdown = '01 August 2015';\n\n//\n// ### function notice(jitsu)\n// Prints the notice on top of each command\n//\ngodaddy.notice = function notice(jitsu) {\n  jitsu.log.warn();\n  jitsu.log.warn('Nodejitsu has been acquired by '.bold + 'GoDaddy'.green.bold);\n  jitsu.log.warn();\n  jitsu.log.warn('Read more at: ' + 'https://nodejitsu.com/godaddy'.bold);\n  jitsu.log.warn('Or run:       ' + 'jitsu godaddy'.bold);\n  jitsu.log.warn();\n};\n\n//\n// ### function disabled(jitsu)\n// This method has been disabled.\n//\ngodaddy.disabled = function disabled(jitsu, command) {\n  jitsu.log.error();\n  jitsu.log.error('The command `jitsu '+ command+'` has been disabled as we\\'ve');\n  jitsu.log.error('been acquired by GoDaddy. Run '+ 'jitsu godaddy'.cyan +' for more');\n  jitsu.log.error('information or visit: https://nodejitsu.com/godaddy');\n  jitsu.log.error();\n  jitsu.log.info('Nodejitsu '.grey + 'not ok'.red.bold);\n};\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/usage.js":"/*\n * usage.js: Text for `jitsu help`.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar colors = require('colors');\n\nmodule.exports = [\n  '          ___  __'.cyan,\n  '    /  /  /   /_  /  /'.cyan,\n  ' __/  /  /   __/ /__/'.cyan,\n  '',\n\n  'Flawless deployment of Node.js apps to the cloud',\n  'open-source and fully customizable.',\n  'https://github.com/nodejitsu/jitsu',\n  '',\n\n  'Usage:'.cyan.bold.underline,\n  '',\n  '  jitsu <resource> <action> <param1> <param2> ...',\n  '',\n\n  'Common Commands:'.cyan.bold.underline,\n  '',\n\n  'To learn more about the GoDaddy acquisition'.cyan,\n  '  jitsu godaddy',\n  '',\n\n  'To log into Nodejitsu'.cyan,\n  '  jitsu login',\n  '',\n\n  'To install a pre-built application'.cyan,\n  '  jitsu install',\n  '',\n\n  'Deploys current path to Nodejitsu'.cyan,\n  '  jitsu deploy',\n  '',\n\n  'Lists all applications for the current user'.cyan,\n  '  jitsu list',\n  '',\n\n  'Additional Commands'.cyan.bold.underline,\n  '  jitsu apps',\n  '  jitsu cloud',\n  '  jitsu logs',\n  '  jitsu env',\n  '  jitsu conf',\n  '  jitsu users',\n  '  jitsu databases',\n  '  jitsu snapshots',\n  '  jitsu tokens',\n  '  jitsu logout'\n];\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/properties.js":"/*\n * properties.js: Properties for the prompts in jitsu\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nmodule.exports = {\n  inviteCode: {\n    name: 'invite code',\n    message: 'Invite Code',\n    validator: /^\\w+$/,\n    warning: 'Invite code can only be letters, and numbers'\n  },\n  askstarter: {\n    name: 'askstarter',\n    message: 'Use a node app? (recommended)',\n    default: 'yes'\n  },\n  appname: {\n    name: 'appname',\n    message: 'Name of the app',\n    default: 'myapp'\n  },\n  snapshot: {\n    name: 'snapshot',\n    message: 'Snapshot Name',\n    validator: /^[\\w|\\-|\\.]+$/,\n    warning: 'Snapshot can only be letters, numbers, dashes, and dots',\n    default: (function () {\n      return '';\n    })()\n  },\n  starter: {\n    name: 'starter',\n    message: 'Which node app to install?',\n    default: 'helloworld'\n  },\n  proceed: {\n    name: 'proceed',\n    message: 'Proceed anyway?',\n    default: 'no',\n    validator: /^y[es]*|n[o]?$/\n  },\n  yesno: {\n    name: 'yesno',\n    message: 'are you sure?',\n    validator: /y[es]*|n[o]?/,\n    warning: 'Must respond yes or no',\n    default: 'no'\n  },\n  \"start_local\": {\n    name: 'start_local',\n    message: 'Start this application locally?',\n    validator: /y[es]?|n[o]?/,\n    warning: 'Must respond yes or no',\n    default: 'yes'\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/config.js":"/*\n * config.js: Configuration for the jitsu CLI.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar path = require('path'),\n    jitsu = require('../jitsu');\n\n//\n// Store the original `jitsu.config.load()` function\n// for later use.\n//\nvar _load = jitsu.config.load;\n\n//\n// Update env if using Windows\n//\nif (process.platform == \"win32\") {\n  process.env.HOME = process.env.USERPROFILE;\n}\n\n//\n// Setup target file for `.jitsuconf`.\n//\n//\n// TODO: Refactor broadway to emit `bootstrap:after` and put this\n//       code in a handler for that event\n//\ntry {\n  jitsu.config.env().file({\n    file: jitsu.argv.jitsuconf || jitsu.argv.j || '.jitsuconf',\n    dir: process.env.HOME,\n    search: true\n  });\n}\ncatch (err) {\n  console.log('Error parsing ' + jitsu.config.stores.file.file.magenta);\n  console.log(err.message);\n  console.log('');\n  console.log('This is most likely not an error in jitsu');\n  console.log('Please check the .jitsuconf file and try again');\n  console.log('');\n  process.exit(1);\n}\n\n\nvar defaults = {\n  analyze: true,\n  \"apiTokenName\": 'jitsu',\n  release: 'build',\n  colors: true,\n  loglevel: 'info',\n  loglength: 110,\n  protocol: 'https',\n  remoteHost: 'api.nodejitsu.com',\n  requiresAuth: ['apps', 'databases', 'env', 'logs', 'snapshots'],\n  root: process.env.HOME,\n  timeout: 4 * 60 * 1000,\n  tmproot: path.join(process.env.HOME, '.jitsu/tmp'),\n  userconfig: '.jitsuconf',\n  logs: {\n    host: \"logs.nodejitsu.com\",\n    port: 443,\n    protocol: \"https\"\n  }\n};\n\nObject.defineProperty(defaults, 'remoteUri', {\n  get: function () {\n    var port = jitsu.config.get('port') || '';\n    if (port) {\n      port = ':' + port;\n    }\n\n    return [jitsu.config.get('protocol'), '://', jitsu.config.get('remoteHost'), port].join('');\n  }\n});\n\n//\n// Set defaults for `jitsu.config`.\n//\njitsu.config.defaults(defaults);\n\n//\n// Use the `flatiron-cli-config` plugin for `jitsu config *` commands\n//\njitsu.use(require('flatiron-cli-config'), {\n  store: 'file',\n  restricted: [\n    'auth',\n    'root',\n    'remoteUri',\n    'tmproot',\n    'userconfig'\n  ],\n  before: {\n    list: function () {\n      var username = jitsu.config.get('username'),\n          configFile = jitsu.config.stores.file.file;\n\n      var display = [\n        ' here is the ' + configFile.grey + ' file:',\n        'To change a property type:',\n        'jitsu config set <key> <value>',\n      ];\n\n      if (!username) {\n        jitsu.log.warn('No user has been setup on this machine');\n        display[0] = 'Hello' + display[0];\n      }\n      else {\n        display[0] = 'Hello ' + username.green + display[0];\n      }\n\n      display.forEach(function (line) {\n        jitsu.log.help(line);\n      });\n\n      return true;\n    }\n  }\n});\n\n//\n// Override `jitsu.config.load` so that we can map\n// some existing properties to their correct location.\n//\njitsu.config.load = function (callback) {\n  _load.call(jitsu.config, function (err, store) {\n    if (err) {\n      return callback(err, true, true, true);\n    }\n\n    jitsu.config.set('userconfig', jitsu.config.stores.file.file);\n\n    if (store.auth) {\n      var auth = store.auth.split(':');\n      jitsu.config.clear('auth');\n      jitsu.config.set('username', auth[0]);\n      jitsu.config.set('password', auth[1]);\n      // create a new token and remove password from being saved to .jitsuconf\n      jitsu.tokens.create(auth[0], (jitsu.config.get('apiTokenName')||'jitsu'), function(err, result) {\n          if(!err && result) {\n            var token = Object.getOwnPropertyNames(result).filter(function(n){return n !== 'operation'}).pop();\n            jitsu.config.set('apiToken', result[token]);\n            jitsu.config.set('apiTokenName', token);\n            jitsu.config.clear('password');\n            return jitsu.config.save(callback);\n          }\n        });\n\n\n    }\n\n    callback(null, store);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/alias.js":"/*\n * alias.js: Aliases commands for jitsu.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar jitsu = require('../jitsu');\n\n//\n// Alias the appropriate commands for simplier CLI usage\n//\njitsu.alias('cloud',   { resource: 'apps',   command: 'cloud' });\njitsu.alias('destroy', { resource: 'apps',   command: 'destroy' });\njitsu.alias('deploy',  { resource: 'apps',   command: 'deploy' });\njitsu.alias('publish', { resource: 'apps',   command: 'deploy' });\njitsu.alias('d',       { resource: 'apps',   command: 'deploy' });\njitsu.alias('push',    { resource: 'apps',   command: 'deploy' });\njitsu.alias('list',    { resource: 'apps',   command: 'list' });\njitsu.alias('ls',      { resource: 'apps',   command: 'list' });\njitsu.alias('l',       { resource: 'apps',   command: 'list' });\njitsu.alias('view',    { resource: 'apps',   command: 'view' });\njitsu.alias('v',       { resource: 'apps',   command: 'view' });\njitsu.alias('stop',    { resource: 'apps',   command: 'stop' });\njitsu.alias('start',   { resource: 'apps',   command: 'start' });\njitsu.alias('restart', { resource: 'apps',   command: 'restart' });\njitsu.alias('forgot',  { resource: 'users',  command: 'forgot' });\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/commands.js":"/*\n * commands.js: Configuration for commands provided by flatiron plugins.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar jitsu = require('../jitsu');\n\njitsu.use(require('flatiron-cli-users'), {\n  before: {\n    login: function (details, next) {\n      if (!details || !details.username) {\n        jitsu.log.help('An activated nodejitsu account is required to login');\n        jitsu.log.help('To create a new account use the ' + 'jitsu signup'.magenta + ' command');\n      }\n      next();\n    }\n  },\n  after: {\n    create: function (details) {\n      jitsu.log.help('Please check for an email sent to ' + details.email.grey + ' for further activation instructions.');\n    },\n    login: function (details, next) {\n      //\n      // Retrieve a token and remove the password with it\n      //\n      if (details && details.username) {\n        jitsu.tokens.create(details.username, (jitsu.config.get('apiTokenName')||'jitsu'), function(err, result) {\n          if(!err && result) {\n            var token = Object.getOwnPropertyNames(result).filter(function(n){return n !== 'operation'}).pop();\n            jitsu.config.set('apiToken', result[token]);\n            jitsu.config.set('apiTokenName', token);\n            jitsu.config.clear('password');\n            jitsu.config.save();\n            return next();\n          }\n        });\n      }\n    },\n    logout: function(details, next){\n      jitsu.config.clear('apiToken');\n      jitsu.config.save();\n      return next();\n    }\n  }\n});\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/common/index.js":"/*\n * index.js: Top-level include for the utils module.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    flatiron = require('flatiron'),\n    dateformat = require('dateformat'),\n    async = flatiron.common.async,\n    request = require('request'),\n    semver = require('semver'),\n    jitsu = require('../../jitsu');\n\nvar common = module.exports = flatiron.common.mixin({}, flatiron.common);\n\n//\n// ### function formatApp (app, exclude)\n// #### @app {Object} Application document to format\n// #### @exclude {Array} **Optional** List of additional properties to exclude\n// Formats the specified `app` by removing unnecessary properties combined with\n// any additional properties the caller wishes to `exclude`.\n//\ncommon.formatApp = function (app, exclude) {\n  var snapshots = app.snapshots,\n      remove = ['_id', '_rev', 'id', 'resource'];\n\n  app.snapshots = !snapshots ? [] : snapshots.map(function (snap) {\n    var created = new Date(snap.ctime);\n    created = dateformat(created, \"mm/dd HH:MM:ss Z\");\n    return {\n      id: snap.id,\n      created: created\n    }\n  });\n\n  if (exclude) {\n    remove = remove.concat(exclude);\n  }\n\n  //\n  // TODO: won't work with current rendering of package.json\n  //\n  // app.state = common.formatAppState(app.state);\n\n  //\n  // Update the ctime and mtime of the document to a more human-readable format\n  //\n  app.ctime = dateformat(app.ctime, \"mm/dd HH:MM:ss Z\");\n  app.mtime = dateformat(app.mtime, \"mm/dd HH:MM:ss Z\");\n\n  //\n  // Format ctime to more human-readable format for snapshots if they are available\n  //\n  if (app.active) {\n    app.active.ctime = dateformat(app.active.ctime, \"mm/dd HH:MM:ss Z\");\n  }\n\n  if (app.running) {\n    app.running.ctime = dateformat(app.running.ctime, \"mm/dd HH:MM:ss Z\");\n  }\n\n\n  remove.forEach(function (key) {\n    delete app[key];\n  });\n\n  return app;\n}\n\ncommon.formatAppState = function (state) {\n\n  var str;\n\n  if (state === \"started\") {\n    str = state.green;\n  } else {\n    str = (state || 'unknown').grey;\n  }\n\n  return str;\n\n};\n\n//\n// ### function missingKeys (source, target)\n// #### @source {Array} List of keys for the current object\n// #### @target {Array} List of keys for the new object\n// Returns the complement of the intersection of the two arrays.\n//\n// e.g. [1,2,3,5], [1,2,3,4,5] => [4]\n//\ncommon.missingKeys = function (source, target) {\n  var missing = [];\n\n  source.forEach(function (key) {\n    if (target.indexOf(key) === -1) {\n      missing.push(key);\n    }\n  });\n\n  return missing;\n};\n\n//\n// ### function objectDiff (current, update, level)\n// #### @current {Object} Current representation of the object.\n// #### @update {Object} Updated representation of the object.\n// #### @level {Number} Level in the object we are diffing.\n// Returns an incremental diff of the `current` object\n// against the updated representation `update`\n//\n// e.g. { foo: 1, bar: 2 }, { foo: 2, bar: 2 } => { foo: 2 }\n//\ncommon.objectDiff = function (current, update, level) {\n  var ckeys = Object.keys(current),\n      ukeys = Object.keys(update),\n      diff = {};\n\n  //\n  // Ignore changes on the first level of the object.\n  //\n  level = level || 0;\n  if (level > 0) {\n    common.missingKeys(ckeys, ukeys).forEach(function (key) {\n      diff[key] = undefined;\n    });\n  }\n\n  ukeys.forEach(function (key) {\n    var nested, i;\n\n    if (!current[key]) {\n      diff[key] = update[key];\n    }\n    else if (Array.isArray(update[key])) {\n      if (update[key].length !== current[key].length) {\n        diff[key] = update[key];\n      }\n      else {\n        for (i = 0; i < update[key]; i += 1) {\n          if (current[key].indexOf(update[key][i]) === -1) {\n            diff[key] = update[key];\n            break;\n          }\n        }\n      }\n    }\n    else if (typeof update[key] === 'object') {\n      if ((nested = common.objectDiff(current[key], update[key], level + 1))) {\n        diff[key] = update[key];\n      }\n    }\n    else {\n      if (current[key] !== update[key]) {\n        diff[key] = update[key];\n      }\n    }\n  });\n\n  return Object.keys(diff).length > 0 ? diff : null;\n};\n\ncommon.checkVersion = function (callback) {\n  var responded = false\n\n  //\n  // Check the GitHub tags for `jitsu` to see if the current\n  // version is outdated. If it is not make sure to message the user at the end.\n  //\n  request({\n    uri: 'http://registry.npmjs.org/jitsu/latest',\n    timeout: 1000\n  }, function (err, res, body) {\n    if (!responded) {\n      responded = true;\n\n      try {\n        var pkg = JSON.parse(body);\n\n        if (semver.gt(pkg.version, jitsu.version)) {\n          jitsu.log.warn('A newer version of ' + 'jitsu'.magenta + ' is available. ' + 'please update immediately');\n          jitsu.log.help('To install the latest ' + 'jitsu'.magenta + ' type `[sudo] npm install jitsu -g`');\n          jitsu.log.warn('To ' + 'continue'.bold + ' without an update ' + 'type'.cyan  + ' ' + '\\'yes\\''.magenta);\n\n          jitsu.prompt.confirm('Continue without updating? Bad things might happen (no)', function (err, result) {\n            return err ? callback() : callback(!result);\n          });\n\n          return;\n        }\n\n        callback();\n      }\n      catch (ex) {\n        //\n        // Ignore errors from GitHub. We will notify the user\n        // of an upgrade at the next possible opportunity.\n        //\n        callback();\n      }\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/package.js":"/*\n * package.js: Utilities for working with package.json files.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    existsSync = fs.existsSync || path.existsSync,\n    util = require('util'),\n    punycode = require('punycode'),\n    spawnCommand = require('spawn-command'),\n    zlib = require('zlib'),\n    async = require('flatiron').common.async,\n    analyzer = require('require-analyzer'),\n    semver = require('semver'),\n    jitsu = require('../jitsu'),\n    ladder = require('ladder'),\n    fstream = require('fstream'),\n    ProgressBar = require('progress'),\n    fstreamNpm = require('fstream-npm'),\n    tar = require('tar');\n\nvar package = exports;\n\n//\n// ### function get (dir, callback)\n// #### @dir {string} Directory to get the package.json from\n// #### @options {object} Ignored\n// #### @callback {function} Continuation to respond to when complete\n// Attempts to read the package.json from the specified `dir`. If it is\n// unable to do, walks the user through creating a new one from scratch.\n//\npackage.get = function (dir, options, callback) {\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  package.read(dir, function (err, pkg) {\n    if (err) {\n      if (err.toString() === \"Error: Invalid package.json file\") {\n        jitsu.log.error(err.toString());\n        return callback(\n          'Please make sure ' + (path.join(dir, '/package.json')).grey + ' is valid JSON',\n          false,\n          false\n        );\n      }\n      return package.create(dir, callback);\n    }\n\n    package.validate(pkg, dir, options, function (err, updated) {\n      return err ? callback(err) : callback(null, updated);\n    });\n  });\n};\n\n//\n// ### function read (dir, callback)\n// #### @dir {string} Directory to read the package.json from\n// #### @callback {function} Continuation to pass control to when complete\n// Attempts to read the package.json file out of the specified directory.\n//\npackage.read = function (dir, callback) {\n  var file = path.resolve(path.join(dir, 'package.json'));\n\n  fs.readFile(file, function (err, data) {\n    if (err) {\n      return callback(err);\n    }\n\n    data = data.toString();\n\n    if (!data.length) {\n      return callback(new Error('package.json is empty'));\n    }\n\n    try {\n      data = JSON.parse(data.toString());\n    }\n    catch (ex) {\n      return callback(new Error('Invalid package.json file'));\n    }\n\n    callback(null, data);\n  });\n};\n\n//\n// ### function tryRead (dir, callback, success)\n// #### @dir {string} Directory to try to read the package.json from.\n// #### @callback {function} Continuation to respond to on error.\n// #### @success {function} Continuation to respond to on success.\n// Attempts to read the package.json file from the specified `dir`; responds\n// to `callback` on error and `success` if the read operation worked.\n//\npackage.tryRead = function (dir, callback, success) {\n  package.read(dir, function (err, pkg) {\n    return err ? callback(new Error('No package found at ' + (dir + '/package.json').grey), true) : success(pkg);\n  });\n};\n\n//\n// ### function createPackage (dir, callback)\n// #### @dir {string} Directory to create the package.json in\n// #### @callback {function} Continuation to respond to when complete\n// Walks the user through creating a simple package.json in the specified\n// `dir` then writes to file and responds to `callback`.\n//\npackage.create = function (dir, callback) {\n  var help = [\n    '',\n    'A package.json stores meta-data about an app',\n    'In order to continue we\\'ll need to gather some information about the app',\n    '',\n    'Press ^C at any time to quit.',\n    'to select a default value, press ENTER'\n  ];\n\n  jitsu.log.warn('There is no package.json file in ' + dir.grey);\n  jitsu.log.warn('Creating package.json at ' + (path.join(dir, '/package.json')).grey);\n\n  help.forEach(function (line) {\n    jitsu.log.help(line);\n  });\n\n  fillPackage(null, dir, function (err, pkg) {\n    if (err) {\n      return callback(err);\n    }\n\n    package.write(pkg, dir, true, function (err, pkg) {\n      if (err) {\n        return callback(err);\n      }\n      tryAnalyze(pkg, dir, callback);\n\n    });\n  });\n};\n\n//\n// ### function validate (pkg, dir, callback)\n// #### @pkg {Object} Parsed package.json to validate\n// #### @dir {string} Directory containing the package.json file\n// #### @options {object} Ignored\n// #### @callback {function} Continuation to respond to when complete\n// Validates the specified `pkg` against the properties list\n// returned from `package.properties(dir)`.\n// Also prompts the user if there are any missing properties.\n//\npackage.validate = function (pkg, dir, options, callback) {\n\n  if (!callback) {\n    callback = options;\n    options = {};\n  }\n\n  var properties = package.properties(dir),\n      missing = [],\n      invalid = [];\n\n  function checkProperty (desc, next) {\n    var nested = desc.name.split('.'),\n        value = pkg[nested[0]];\n\n    if (nested.length > 1 && value) {\n      value = value[nested[1]];\n    }\n\n    // Handle missing values\n    if (!value) {\n      missing.push(desc);\n    }\n\n    // handle invalid values\n    function isValid(desc) {\n      if (desc.validator) {\n        if (desc.validator instanceof RegExp) {\n          return !desc.validator.test(value);\n        }\n\n        return !desc.validator(value);\n      }\n      return false;\n    }\n\n    if (value && isValid(desc)) {\n\n      if (nested.length > 1) {\n        delete pkg[nested[0]][nested[1]];\n      }\n      else {\n        delete pkg[nested[0]];\n      }\n\n      invalid.push(desc);\n    }\n\n    next();\n  }\n\n  async.forEach(properties, checkProperty, function () {\n\n    if (missing.length <= 0 && invalid.length <= 0) {\n      return tryAnalyze(pkg, dir, callback);\n    }\n\n    var help,\n        missingNames = missing.map(function (prop) {\n          return '  ' + (prop.message || prop.name).grey;\n        }),\n        invalidNames = invalid.map(function (prop) {\n          return '  ' + (prop.message || prop.name).grey;\n        });\n\n    help = [\n      ''\n    ];\n\n    if (missingNames.length) {\n      help = help.concat([\n        'The package.json file is missing required fields:',\n        '',\n        missingNames.join(', '),\n        ''\n      ]);\n    }\n\n    if (invalidNames.length) {\n      help = help.concat([\n        'The package.json file has invalid required fields:',\n        '',\n        invalidNames.join(', '),\n        ''\n      ]);\n    }\n\n    help = help.concat([\n      'Prompting user for required fields.',\n      'Press ^C at any time to quit.',\n      ''\n    ]);\n\n    help.forEach(function (line) {\n      jitsu.log.warn(line);\n    });\n\n    fillPackage(pkg, dir, function (err, pkg) {\n      if (err) {\n        return callback(err);\n      }\n\n      package.write(pkg, dir, true, function (err, pkg) {\n        return err\n          ? callback(err)\n          : tryAnalyze(pkg, dir, callback);\n      });\n    });\n  });\n};\n\n//\n// ### function writePackage (pkg, dir, callback)\n// #### @pkg {Object} Data for the package.json\n// #### @dir {string} Directory to write the package.json in\n// #### @callback {function} Continuation to respond to when complete\n// Prompts the user about writing the new package.json file. If the user\n// OKs the operation, attempts to write to file. Otherwise restarts the\n// create operation in the specified `dir`.\n//\npackage.write = function (pkg, dir, create, callback) {\n  function doWrite(err, result) {\n    if (err) {\n      return cb(err);\n    }\n    if (!result) {\n      return create ? package.create(dir, callback) : callback(new Error('Save package.json cancelled.'));\n    }\n\n    fs.readFile(path.resolve(path.join(dir, 'package.json')), function (e, data) {\n      var offset = data ? ladder(data.toString()) : 2;\n\n      fs.writeFile(path.join(dir, 'package.json'), JSON.stringify(pkg, null, offset) + '\\n', function (err) {\n        return err ? callback(err) : callback(null, pkg, dir);\n      });\n    });\n  }\n\n  if (!callback) {\n    callback = create;\n    create = null;\n  }\n\n  delete pkg.analyzed;\n\n  jitsu.log.warn('About to write ' + path.join(dir, 'package.json').magenta);\n\n  //\n  // analyze and throw warnings if any dependencies have version of '*'\n  //\n  policeDependencies(pkg);\n\n  jitsu.inspect.putObject(pkg, 2);\n\n  return jitsu.argv.release\n    ? doWrite(null, true)\n    : jitsu.prompt.confirm('Is this ' + 'ok?'.green.bold, { default: 'yes'}, doWrite);\n};\n\n//\n// ### function analyzeDependencies (pkg, dir, callback)\n// #### @pkg {Object} Parsed package.json to check dependencies for.\n// #### @dir {string} Directory containing the package.json file.\n// #### @callback {function} Continuation to respond to when complete.\n// Analyzes the dependencies in `pkg` using the `require-analyzer` module.\n//\npackage.analyzeDependencies = function (pkg, dir, callback) {\n  jitsu.log.info('Analyzing application dependencies in ' + pkg.scripts.start.magenta);\n  analyzer.analyze({ target: path.join(dir, pkg.scripts.start) }, function (err, pkgs) {\n    //\n    // Create a hash of `'package': '>= version'` for the new dependencies\n    //\n    var versions = analyzer.extractVersions(pkgs),\n        updates;\n\n    if (package.newDependencies(pkg.dependencies, versions)) {\n      //\n      // If there are new dependencies, indicate this to the user.\n      //\n      jitsu.log.info('Found new dependencies. They will be added automatically');\n\n      //\n      // Extract, merge, and display the updates found by `require-analyzer`\n      //\n      updates = analyzer.updates(pkg.dependencies, versions);\n      updates = analyzer.merge({}, updates.added, updates.updated);\n      jitsu.inspect.putObject(updates);\n\n      //\n      // Update the package.json dependencies\n      //\n      pkg.dependencies = analyzer.merge({}, pkg.dependencies || {}, updates);\n    }\n\n    callback(null, pkg, updates);\n  });\n};\n\n//\n// ### function createPackage (dir, callback)\n// #### @dir {string} Directory to create the package *.tgz file from\n// #### @version {string} Optional version to name saved file.\n// #### @callback {function} Continuation to pass control to when complete\n// Creates a *.tgz package file from the specified directory `dir`.\n//\npackage.createTarball = function (dir, version, callback) {\n  if (!callback) {\n    callback = version;\n    version = null;\n  }\n\n  package.read(dir, function (err, pkg) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (dir.slice(-1) === '/') {\n      dir = dir.slice(0, -1);\n    }\n\n    var name = [jitsu.config.get('username'), pkg.name, version || pkg.version].join('-') + '.tgz',\n        tarball = path.join(jitsu.config.get('tmproot'), name);\n\n    fstreamNpm({\n      path: dir,\n      ignoreFiles: ['.jitsuignore', '.npmignore', '.gitignore', 'package.json']\n    })\n      .on('error', callback)\n      .pipe(tar.Pack())\n      .on('error', callback)\n      .pipe(zlib.Gzip())\n      .on('error', callback)\n      .pipe(fstream.Writer({ type: \"File\", path: tarball }))\n      .on('close', function () {\n        callback(null, pkg, tarball);\n      });\n  });\n};\n\n//\n// ### function updateTarball (version, pkg, existing, callback)\n// #### @version {string} **Optional** Version to use for the updated tarball\n// #### @pkg {Object} Current package.json file on disk\n// #### @existing {Object} Remote package.json stored at Nodejitsu\n// #### @callback {function} Continuation to respond to when complete.\n//\n//\npackage.updateTarball = function (version, pkg, existing, firstSnapshot, callback) {\n  if (!callback) {\n    callback = firstSnapshot;\n    firstSnapshot = false;\n  }\n\n  function executeCreate (err) {\n    if (err) {\n      return callback(err, true);\n    }\n\n    version = version || pkg.version;\n    jitsu.package.createTarball(process.cwd(), version, function (err, ign, filename) {\n      if (err) {\n        return callback(err, true)\n      }\n\n      jitsu.log.info('Creating snapshot ' + version.grey);\n      jitsu.log.silly('Filename: ' + filename);\n\n      fs.stat(filename, function (err, stat) {\n        var bar;\n\n        if (err) return callback(err);\n\n        // XXX Is 70mb enough? Please warning message\n        if (stat.size > 70 * 1024 * 1024) {\n          jitsu.log.warn('Snapshot is larger than ' + '70M'.magenta + '!');\n          jitsu.log.warn('Keep size below this limit for successful deploy.');\n        }\n\n        var emitter = jitsu.snapshots.create(pkg.name, version, filename, function (err, res) {\n          if (err) {\n            return callback(err);\n          }\n          res.pipe(process.stdout);\n          res.on('end', function () {\n            if (res.trailers && res.trailers['x-build-failure']) {\n              var error = new Error('Nodejitsu Error: Build Failure, please check the build failure above');\n              error.result = { error: res.trailers['x-build-failure'].toString() };\n              return callback(error);\n            }\n            jitsu.log.info('Done creating snapshot ' + version.magenta);\n            callback(null, version, pkg);\n          });\n        });\n\n        if (emitter && !jitsu.config.get('raw') && process.stdout.isTTY ) {\n          var size;\n          emitter.on('start', function (stats) {\n            size = stats.size;\n            bar = new ProgressBar('info'.green + ':\\t Uploading: [:bar] :percent',{\n              complete  : '=',\n              incomplete: ' ',\n              width     : 30 ,\n              total     : stats.size\n            });\n          });\n\n          emitter.on('data', function (length) {\n            if (bar) bar.tick(length > size ? size : length);\n          });\n\n          emitter.on('end', function () {\n            // fix for bar that sometimes hangs at 99%\n            if (bar) {\n              bar.tick(bar.total - bar.curr);\n            }\n\n            console.log();\n          });\n        }\n      });\n    });\n  }\n\n\n  var start = pkg.scripts.start;\n  if (start.match(/(--watch)/)) {\n    jitsu.log.warn(\"Using the '--watch' flag may eventually cause issues as its only\");\n    jitsu.log.warn(\"intended for development usage.\");\n  }\n\n\n  var old = false;\n\n  if (!firstSnapshot) {\n    jitsu.log.silly('Existing version: ' + existing.version.magenta);\n    jitsu.log.silly('Local version: ' + pkg.version.magenta);\n    old = semver.gte(existing.version, pkg.version);\n\n    if (old) {\n      //\n      // If the existing version is greater than the version in the\n      // package.json file on disk, update it and then write back to disk.\n      //\n      jitsu.log.warn('Local package version appears to be old');\n      jitsu.log.warn('The ' + 'package.json'.grey + ' version will be incremented automatically');\n      //\n      // Check for release args then .jitsuconf or default to 'build'\n      //\n      var release = jitsu.argv.release || jitsu.config.get('release') || 'build';\n      //\n      // Pattern matching to see if release is version number or type\n      // If is version number, set release to version number specified\n      //\n      if (jitsu.argv.release) {\n        if (typeof(jitsu.argv.release) == 'string') {\n          var releaseIsVersionNumber = jitsu.argv.release.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)/g);\n\n          if (releaseIsVersionNumber) {\n            pkg.version = jitsu.argv.release;\n          } else {\n            pkg.version = semver.inc(existing.version, release);\n          }\n\n        }\n      //\n      // if no release argument specified use .jitsuconf\n      //\n      } else {\n        pkg.version = semver.inc(existing.version, release);\n      }\n      //\n      // Default to build if user inputs as -r arg something ridiculous\n      //\n      if (pkg.version === null) {\n        pkg.version = semver.inc(existing.version, jitsu.config.get('release') || 'build');\n      }\n    }\n  }\n\n  return old\n    ? package.write(pkg, process.cwd(), executeCreate)\n    : executeCreate();\n};\n\n//\n// ### function newDependencies (current, updated)\n// #### @current {Object} Set of current dependencies\n// #### @updated {Object} Set of updated dependencies\n// Returns a value indicating if there are any new dependencies\n// in `updated` as compared to `current`.\n//\npackage.newDependencies = function (current, updated) {\n  var updates = analyzer.updates(current, updated);\n  return Object.keys(updates.added).length > 0 || Object.keys(updates.updated).length > 0;\n};\n\n//\n// ### function properties (dir)\n// #### @dir {string} Directory in which the package.json properties are being used\n// Returns a new set of properties to be consumed by `jitsu.prompt` to walk a user\n// through creating a new `package.json` file.\n//\npackage.properties = function (dir) {\n  return [\n    {\n      name: 'name',\n      unique: true,\n      message: 'Application name',\n      validator: /^(?!\\.)(?!_)(?!node_modules)(?!favicon.ico)[^\\/@\\s\\+%:\\n]+$/,\n      warning: 'The application name  must follow the rules for npm package names.\\n'+\n      '         They must not start with a \\'.\\' or \\'_\\', contain any whitespace \\n'+\n      '         characters or any of the following characters(between quotes): \"/@+%:\". \\n'+\n      '         Additionally, the name may not be \\'node_modules\\' or \\'favicon.ico\\'.',\n      default: path.basename(dir)\n    },\n    {\n      name: 'subdomain',\n      unique: true,\n      message: 'Subdomain name',//+\n      warning: 'The subdomain must follow the rules for ARPANET host names.  They must\\n'+\n      '         start with a letter, end with a letter or digit, and have as interior\\n'+\n      '         characters only letters, digits, and hyphen.  There are also some\\n'+\n      '         restrictions on the length.  Labels must be 63 characters or less.\\n'+\n      '         There are a few exceptions, underscores may be used as an interior \\n'+\n      '         character and unicode characters may be used that are supported under\\n'+\n      '         punycode.',\n      validator: function(s){\n        var reValidSubdomain = /^[a-zA-Z]$|^[a-zA-Z][a-zA-Z\\d]$|^[a-zA-Z][\\w\\-]{1,61}[a-zA-Z\\d]$/;\n        if(s.indexOf('.') !== -1) { // We will support multiple level subdomains this for now warn user...\n          jitsu.log.warn(\"**WARNING** Do not use multiple level subdomains, they will be going away soon!\");\n          var subdomainNames = s.split('.'),\n              names = subdomainNames.map(punycode.toASCII);\n          return !names.some(function(name){return !reValidSubdomain.test(name);});\n        } else {\n          return reValidSubdomain.test(punycode.toASCII(s));\n        }\n      },\n      help: [\n        '',\n        'The ' + 'subdomain '.grey + 'is where the app will reside',\n        'The app will then become accessible at: http://' + 'subdomain'.grey + '.jit.su',\n        ''\n      ],\n      default: jitsu.config.get('username') + '-' + path.basename(dir)\n    },\n    {\n      name: 'scripts.start',\n      message: 'scripts.start',\n      conform: function (script) {\n        //\n        // Support `scripts.start` starting with executable (`node` or `coffee`).\n        //\n        var split = script.split(' ');\n        if (~['node', 'coffee'].indexOf(split[0])) {\n          script = split.slice(1).join(' ');\n        }\n\n        try {\n          fs.statSync(path.join(dir, script));\n          return true;\n        }\n        catch (ex) {\n          return false;\n        }\n      },\n      warning: 'Start script was not found in ' + dir.magenta,\n      default: searchStartScript(dir)\n    },\n    {\n      name: 'version',\n      unique: false,\n      conform: semver.valid,\n      default: '0.0.0'\n    },\n    {\n      name: 'engines.node',\n      unique: false,\n      message: 'engines',\n      conform: semver.validRange,\n      default: '0.10.x'\n    }\n  ];\n};\n\n//\n// ### function available (pkg, dir, callback, createPackage)\n// #### @pkg {Object} Current package.json file on disk\n// #### @dir {string} Directory in which the package.json properties are being used\n// #### @callback {function} Continuation to respond to when complete.\n// #### @createPackage {function} Function needed to make it recursive\n// Prompts for appname and subdomain until the combination is available\n//\npackage.available = function (pkg, dir, callback, createPackage) {\n  jitsu.apps.available(pkg, function (err, isAvailable) {\n    var props, fields = [];\n    function removeAppname(){\n      delete pkg.name;\n      fields.push('name');\n    }\n    function removeSubdomain(){\n      delete pkg.subdomain;\n      fields.push('subdomain');\n    }\n    function addProps(){\n      props = package.properties(dir).filter(function (p) {\n        return fields.indexOf(p.name) !== -1;\n      });\n      // auto-suggest a new domain field based on username\n      for (var p in props) {\n        if (props[p].name === 'subdomain') {\n          props[p].default = props[p].default + '.' + jitsu.config.get('username');\n        }\n      }\n      jitsu.prompt.addProperties(pkg, props, createPackage);\n      return;\n    }\n    if (err) {\n      jitsu.log.error('There was an error while checking app name / subdomain availability.');\n      return callback(err);\n    } else if (!isAvailable.available) {\n      // only appname is taken\n      if(!isAvailable.appname && isAvailable.subdomain){\n        jitsu.log.error('The app name requested is already in use');\n        jitsu.prompt.confirm('It appears you have already used this appname before ('+pkg.name.magenta+'). ' + 'Overwrite?'.green.bold, { default: 'yes'}, function (err, result) {\n          if (err) {\n            return callback(err);\n          }\n          if (!result){\n            removeAppname();\n            addProps();\n          } else {\n            callback(null, pkg);\n          }\n\n        });\n      }\n      // only subdomain is taken\n      else if(isAvailable.appname && !isAvailable.subdomain){\n        jitsu.log.error('The subdomain requested is already in use');\n        removeSubdomain();\n        addProps();\n      }\n      //both are taken\n      else if(!isAvailable.appname && !isAvailable.subdomain){\n        jitsu.log.error('The subdomain and app name requested are already in use');\n        jitsu.prompt.confirm('This app already exists! ('+pkg.name.magenta+'). ' + 'Do you want to deploy over it?'.green.bold, { default: 'yes'}, function (err, result) {\n          if (err) {\n            return callback(err);\n          }\n          if (!result){\n            removeAppname();\n            removeSubdomain();\n            addProps();\n          } else {\n            callback(null, pkg);\n          }\n\n        });\n\n      }\n    } else { //nothing is wrong\n      callback(null, pkg);\n    }\n  });\n};\n\npackage.runScript = function (pkg, action, callback) {\n  var command = pkg.scripts[action];\n\n  if (!command) {\n    //\n    // If there's no such script, it's all fine.\n    //\n    return callback();\n  }\n\n  var child = spawnCommand(command, {\n    customFds: [0, 1, 2]\n  });\n\n  child.on('exit', function (code) {\n    if (code !== 0) {\n      return callback(new Error('`' + command + '` exited with code ' + code));\n    }\n\n    callback();\n  });\n};\n\nfunction searchStartScript(dir) {\n  var scripts = ['server', 'app', 'index', 'bin/server'],\n      script,\n      i;\n\n  for (i in scripts) {\n    script = path.join(dir, scripts[i]);\n    if (existsSync(script)) {\n      return 'node ' + scripts[i];\n    }\n    else if (existsSync(script + '.js')) {\n      return 'node ' + scripts[i] + '.js';\n    }\n    else if (existsSync(script + '.coffee')) {\n      return 'coffee ' + scripts[i] + '.coffee';\n    }\n  }\n}\n\nfunction tryAnalyze (target, dir, callback) {\n\n  if (target.analyzed) {\n    return callback(null, target);\n  }\n\n  var noanalyze = !((jitsu.config.get('analyze') === 'true')\n    || (jitsu.config.get('analyze') === true))\n    || ((jitsu.config.get('noanalyze') === 'true')\n    || (jitsu.config.get('noanalyze') === true))\n    || ((target.analyze === 'false')\n    || (target.analyze === false));\n\n  if (noanalyze) {\n    jitsu.log.info('Skipping require-analyzer because ' + 'noanalyze'.magenta + ' option is set');\n    return callback(null, target);\n  }\n\n  package.analyzeDependencies(target, dir, function (err, addedDeps, updates) {\n    if (err) {\n      return callback(err);\n    }\n\n    target.analyzed = true;\n    return updates\n      ? package.write(addedDeps, dir, true, callback)\n      : callback(null, addedDeps);\n  });\n}\n\nfunction policeDependencies (pkg) {\n  dependencies = pkg.dependencies;\n  for (var key in dependencies) {\n    if (dependencies[key].toString().match(/(\\*)/)) {\n      jitsu.log.warn(\"Using '\" + \"*\".magenta + \"' as a version for dependencies may eventually cause issues\");\n      jitsu.log.warn('Use specific versions for dependencies to avoid future problems');\n      jitsu.log.warn('See: ' + 'http://package.json.jit.su'.grey + ' for more information');\n      return false;\n    }\n  }\n}\n\nfunction fillPackage (base, dir, callback) {\n  base = base || {};\n  var subdomain, descriptors, missing;\n\n  missing = ['name', 'subdomain', 'version'].filter(function (prop) {\n    return !base[prop]\n  });\n\n  if (!(base.scripts && base.scripts.start)) {\n    missing.push('scripts.start');\n  }\n\n  if (!(base.engines && base.engines.node)) {\n    missing.push('engines.node');\n  }\n\n  descriptors = package.properties(dir).filter(function (descriptor) {\n    if (descriptor.name == 'subdomain') {\n      subdomain = descriptor;\n    }\n\n    return missing.indexOf(descriptor.name) !== -1;\n  });\n\n  jitsu.prompt.addProperties(base, descriptors, function createPackage (err, result) {\n\n    if (err) {\n      //\n      // TODO: Something here...\n      //\n      jitsu.log.error('Unable to add properties to package description.');\n      jitsu.log.error(util.inspect(err));\n      return callback(err);\n    }\n\n    var isUnique = descriptors.filter(function (descriptor) {\n      return descriptor.unique;\n    }).length;\n\n    result.scripts = result.scripts || {};\n\n    if (isUnique) {\n      package.available(result, dir, callback, createPackage);\n    }\n    else {\n      callback(null, result); // TODO\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/common/logfile.js":"var fs = require('fs');\nvar MB = 1024 * 1024;\nfunction LogFile(filePath, maxSize) {\n  var self = this;\n  this.size = 2;\n  this.maxSize = maxSize || MB;\n  this.filePath = filePath;\n  try {\n    fs.statSync(this.filePath)\n    this.content = JSON.parse(fs.readFileSync(filePath));\n    this.content = this.content.map(function (item) {\n      var str = JSON.stringify(item, null, ' ');\n      self.size += str.length + 1;\n      return str;\n    })\n  }\n  catch(e) {\n    this.content = [];\n  }\n  this.prune();\n}\nexports.LogFile = LogFile;\nLogFile.prototype.prune = function prune() {\n  while(this.size > this.maxSize) {\n    var obj = this.content.shift();\n    this.size -= obj.length + 1;\n  }\n}\nLogFile.prototype.log = function log(object) {\n  var str = JSON.stringify(object, null, ' ');\n  this.size += str.length + 1;\n  this.content.push(str);\n  this.prune();\n  str = this.toString();\n  fs.writeFile(this.filePath, str);\n}\nLogFile.prototype.toString = function toString() {\n  return '[\\n'+this.content.join(',\\n')+'\\n]\\n';\n}\n","/home/travis/build/npmtest/node-npmtest-jitsu/node_modules/jitsu/lib/jitsu/commands/apps.js":"/*\n * apps.js: Commands related to app resources\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar analyzer = require('require-analyzer'),\n    opener   = require('opener'),\n    jitsu    = require('../../jitsu'),\n    utile    = jitsu.common,\n    async    = utile.async;\n\nvar apps = exports;\n\napps.usage = [\n  'The `jitsu apps` command manages',\n  'Applications on Nodejitsu. Valid commands are:',\n  '',\n  'jitsu apps deploy',\n  'jitsu apps list',\n  'jitsu apps create',\n  'jitsu apps cloud   [<name>]',\n  'jitsu apps view    [<name>]',\n  'jitsu apps update  [<name>]',\n  'jitsu apps destroy [<name>]',\n  'jitsu apps start   [<name>]',\n  'jitsu apps restart [<name>]',\n  'jitsu apps stop    [<name>]',\n  'jitsu apps setdrones [<name>] <number>',\n  '',\n  'For commands that take a <name> parameter, if no parameter',\n  'is supplied, jitsu will attempt to read the package.json',\n  'from the current directory.'\n];\n\nfunction handleStartError(err, name, callback) {\n  //\n  // TODO: replace this error handling with errs library\n  //\n  if (err.result) {\n    if (err.result.message === \"Cannot start application with no snapshots\") {\n      jitsu.log.error('Cannot start ' + name.magenta + ' since it has no snapshots');\n      jitsu.log.help('Try running a ' + 'jitsu deploy'.magenta);\n      return callback({}, null);\n    }\n    else if (err.result.error === 'not_found') {\n      jitsu.log.error('App ' + name.magenta + ' doesn\\'t exist on Nodejitsu yet!');\n      return callback({});\n    }\n  }\n  callback(err);\n}\n\n//\n// ### function deploy (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Deploys an application through the following steps:\n// 1. Creates the application (if necessary)\n// 2. Creates or validates the package.json\n// 3. Packages and creates a new snapshot\n// 4. Stops the application (if necessary)\n// 5. Starts the application\n//\napps.deploy = function (callback) {\n  var dir = process.cwd(),\n      args = utile.args(arguments),\n      cloud = {},\n      pkg;\n\n  //\n  // Allows arbitrary amount of arguments to deploy\n  //\n  if (arguments.length) {\n    callback = args.callback;\n  }\n\n  //\n  // Allow use provider name and datacenter name without flags (--provider, --datacenter)\n  //\n  if (arguments.length === 2) {\n    jitsu.log.error('Error: No datacenter name specified');\n    jitsu.log.error('Please use a valid datacenter name.');\n\n    return jitsu.apps.endpoints(function (err, endpoints) {\n      if (err) return callback(err);\n\n      if (endpoints) {\n        jitsu.log.info('You can use one of the following providers');\n        Object.keys(endpoints).forEach(function (provider) {\n          var datacenters = endpoints[provider];\n          Object.keys(datacenters).forEach(function (datacenter) {\n            jitsu.log.data('jitsu deploy ' + provider + ' ' + datacenter);\n          });\n        });\n      }\n\n      return callback(new Error(), true);\n    });\n  }\n\n  if (arguments.length === 3) {\n    cloud.provider = args[0];\n    cloud.datacenter = args[1];\n  }\n\n  // Setup of cloud parameters specified using (--)\n  if (jitsu.argv['provider'] || jitsu.argv['datacenter']) {\n    cloud.provider = jitsu.argv['provider'];\n    cloud.datacenter = jitsu.argv['datacenter'];\n  }\n\n  function startApp(err, existing) {\n    if (err) {\n      jitsu.log.error('Error creating snapshot for app ' + pkg.name.magenta);\n      jitsu.log.error(err.message);\n      return callback(new Error(), true);\n    }\n\n    //if (existing.state === 'started') {\n    //\n    // existing.state is thrown away in check app.\n    // these closures would need to be rearanged so that this closure can see the result of view..\n    //\n\n    //\n    // Enable custom drone number and memory ram\n    //\n    if (jitsu.argv['drones'] && typeof jitsu.argv['drones'] === 'number') {\n      cloud.drones = jitsu.argv['drones'];\n    } else if (cloud.provider && cloud.datacenter) {\n      // Default drones to 1\n      cloud.drones = 1;\n    }\n\n    if (jitsu.argv['ram'] && typeof jitsu.argv['ram'] === 'number') {\n      if ([1, 256, 512, 1024].indexOf(jitsu.argv['ram']) === -1) {\n        jitsu.log.warn('Invalid value of parameter: --ram, using 256 as default');\n        cloud.ram = 256;\n      } else {\n        cloud.ram = jitsu.argv['ram'];\n      }\n    } else if (cloud.provider && cloud.datacenter) {\n      // Default ram to 256\n      cloud.ram = 256;\n    }\n\n    var next = function next (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      jitsu.package.runScript(pkg, 'postdeploy', callback);\n    };\n\n    // Only if all options are correct we pass cloud options\n    if (cloud.provider && cloud.datacenter && cloud.drones && cloud.ram) {\n      apps.start(existing.name, cloud, next);\n    } else {\n      apps.start(existing.name, next);\n    }\n\n    //}\n    //else {\n    //  apps.start(existing.name, callback);\n    //}\n  }\n\n  function activateSnapshot(existing, snapshot) {\n    jitsu.log.info('Activating snapshot ' + snapshot.grey + ' for ' + existing.name.magenta);\n    jitsu.snapshots.activate(existing.name, snapshot, function (err) {\n      jitsu.log.silly('Done activating snapshot ' + snapshot.grey);\n      startApp(err, existing);\n    });\n  }\n\n  function updateApp(existing, snapshot) {\n    jitsu.log.info('Updating app ' + existing.name.magenta);\n    jitsu.apps.update(existing.name, pkg, function (err) {\n\n      if (err) {\n        return callback(err);\n      }\n\n      activateSnapshot(existing, snapshot);\n    });\n  }\n\n  function updateSnapshot(err, existing, firstSnapshot) {\n    if (err) {\n      return callback(err, true, true);\n    }\n\n    jitsu.package.runScript(pkg, 'predeploy', function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      jitsu.package.updateTarball(null, pkg, existing, firstSnapshot, function (err, snapshot) {\n        if (err) {\n          return callback(err, snapshot);\n        }\n\n        updateApp(existing, snapshot);\n      });\n    });\n  }\n\n  function checkApp(err, local) {\n    if (err) {\n      jitsu.log.error(err);\n      return callback(new Error(), true);\n    }\n\n    pkg = local;\n    jitsu.log.silly('Checking if application ' + local.name.magenta + ' exists.');\n    jitsu.apps.view(local.name, function (err, app) {\n      var pkg;\n\n      //\n      // TODO: replace this error handling with errs library\n      //\n      if (err) {\n        if (err.result) {\n          if (err.result.error === 'not_found') {\n\n            jitsu.log.silly('App ' + local.name.magenta + ' doesn\\'t exist!');\n            //\n            // If there is a before filter we should run before creating the app do so,\n            // then create the application.\n            //\n            apps.create(local, function (err, existing) {\n              updateSnapshot(err, existing, true);\n            });\n          }\n          else if (err.statusCode === 403) {\n            jitsu.commands.users.login(function (err) {\n              if (err) {\n                return callback(err, true);\n              }\n\n              pkg = analyzer.merge({}, local);\n              jitsu.package.validate(pkg, dir, updateSnapshot);\n            });\n          }\n          else {\n\n            // Our api can return a number of errors that aren't relevant, such\n            // as '500, app deleted'.\n            pkg = analyzer.merge({}, local);\n            jitsu.package.validate(pkg, dir, updateSnapshot);\n          }\n        }\n        else {\n          return callback(err);\n        }\n      }\n      else {\n        app = app\n          ? { version: app.version }\n          : {};\n        pkg = analyzer.merge({}, local, app);\n        jitsu.package.validate(pkg, dir, updateSnapshot);\n      }\n    });\n  }\n\n  jitsu.package.read(dir, function (err, local) {\n    return err\n      ? jitsu.package.get(dir, checkApp)\n      : jitsu.package.validate(local, dir, {}, checkApp);\n  });\n};\n\napps.deploy.usage = [\n  '',\n  'Deploys an application using the following steps:'.cyan.underline,\n  '',\n  '  1. Creates the application (if necessary)',\n  '  2. Creates or validates the package.json',\n  '  3. Packages and creates a new snapshot',\n  '  4. Stops the application (if necessary)',\n  '  5. Starts the application',\n  '',\n  'jitsu deploy',\n  'jitsu apps deploy'\n];\n\n//\n// ### function list (callback)\n// #### @target {string|Object} **optional** Name of the application to create\n// #### @callback {function} Continuation to pass control to when complete.\n// Creates an application for the package.json in the current directory\n// using `name` if supplied and falling back to `package.name`.\n//\napps.create = function (target, callback) {\n\n  //\n  // Allows arbitrary amount of arguments to deploy\n  //\n  if (arguments.length) {\n    callback = utile.args(arguments).callback;\n  }\n\n  var dir = process.cwd();\n\n  function createApp(err, pkg) {\n    if (err) {\n      return callback(err);\n    }\n    jitsu.log.info('Creating app ' + pkg.name.magenta);\n    jitsu.apps.create(pkg, function (err, res, result) {\n      if (err) {\n        jitsu.log.error('Error creating ' + pkg.name.magenta);\n        jitsu.log.error(err.message);\n        return callback(err);\n      }\n\n      jitsu.log.silly('Done creating app ' + pkg.name.magenta);\n      return callback(null, pkg);\n    });\n  }\n\n  function executeCreate(err, pkg) {\n    if (err) {\n      return callback(err);\n    }\n\n    pkg.state = 'stopped';\n    jitsu.log.info('Checking app availability ' + pkg.name.magenta);\n    jitsu.package.available(pkg, dir, createApp, executeCreate);\n  }\n\n  if (target && typeof target === 'object') {\n    return executeCreate(null, target);\n  }\n\n  jitsu.package.get(process.cwd(), executeCreate);\n};\n\n//\n// Usage for `jitsu apps create`.\n//\napps.create.usage = [\n  'Creates the application basing on `package.json` file in the current',\n  'directory.',\n  '',\n  'jitsu apps create'\n];\n\n//\n// ### function list (callback)\n// #### @callback {function} Continuation to pass control to when complete.\n// Lists the applications for the authenticated user.\n//\napps.list = function (username, callback) {\n\n  var authuser = jitsu.config.get('username') || '';\n\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    username = args[0] || authuser;\n  }\n\n  if (authuser === '') {\n    return jitsu.commands.users.login(function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      jitsu.commands.apps.list(username, callback);\n    });\n  }\n\n  jitsu.log.info('Listing all apps for ' + username.magenta);\n\n  jitsu.apps.list(username, function cb(err, apps) {\n    if (err) {\n      if (err.statusCode === 403) {\n        if (authuser === '') {\n          jitsu.log.error('You are not authorized to list application for user: ' + username.magenta);\n          jitsu.log.error('You need to login to do that!');\n        }\n        else {\n          jitsu.log.error(jitsu.config.get('username').magenta + ' is not authorized to list applications for user: ' + username.magenta);\n        }\n      }\n      return callback(err);\n    }\n\n    if (!apps || apps.length === 0) {\n      jitsu.log.warn('No applications exist.');\n      jitsu.log.help('Try creating one with ' + 'jitsu install'.magenta + ' and then deploy it with ' + 'jitsu deploy'.magenta);\n      return callback();\n    }\n\n    var rows = [['name', 'state', 'subdomain', 'drones', 'running snapshot']],\n        colors = ['underline', 'underline', 'underline', 'underline', 'underline'];\n\n    apps.forEach(function (app) {\n      app.state = jitsu.common.formatAppState(app.state);\n\n      //\n      // Remark: Attempt to always show running snapshot\n      //\n      var snapshot = '---';\n      if (app.running && app.running.filename) {\n        snapshot = app.running.filename;\n      }\n\n      rows.push([\n        app.name,\n        app.state,\n        app.subdomain,\n        app.drones + '/' + app.maxDrones,\n        snapshot\n      ]);\n    });\n\n    jitsu.inspect.putRows('data', rows, colors);\n    callback();\n  });\n};\n\n//\n// Usage for `jitsu apps list`\n//\napps.list.usage = [\n  'Lists all of the applications for the current user',\n  '',\n  'jitsu list',\n  'jitsu apps list'\n];\n\n//\n// ### function view (name, callback)\n// #### @name {string} **optional** Name of the application to view\n// #### @callback {function} Continuation to pass control to when complete.\n// Views the application with the specfied `name` for the authenticated user.\n// If no name is supplied this will view the application in the current directory.\n//\napps.view = function (name, callback) {\n\n  //\n  // Allows arbitrary amount of arguments\n  //\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    name = args[0] || null;\n  }\n\n  function executeView(name) {\n    name = name || 'no-name';\n    jitsu.apps.view(name, function (err, app) {\n\n      if (err) {\n        jitsu.log.error('App ' + name.magenta + ' doesn\\'t exist on Nodejitsu yet!');\n        jitsu.log.help('Try running ' + 'jitsu deploy'.magenta);\n        return callback({});\n      }\n\n      jitsu.log.info('Viewing app ' + name.magenta);\n      app = jitsu.common.formatApp(app);\n      jitsu.inspect.putObject(app);\n      callback(null, app);\n    });\n  }\n\n  function getAppName(callback) {\n    jitsu.package.read(process.cwd(), function (err, pkg) {\n      if (!err) {\n        jitsu.log.info('Attempting to view app ' + (process.cwd()+ '/package.json').grey);\n        return callback(null, pkg.name);\n      }\n      callback(err);\n    });\n  }\n\n  if (!name) {\n    getAppName(function (err, pkg) {\n      if (err) {\n        jitsu.commands.list(function () {\n          jitsu.log.info('Which ' + 'app'.magenta + ' to view?');\n          jitsu.prompt.get([\"app name\"], function (err, result) {\n            if (err) {\n              jitsu.log.error('Prompt error:');\n              return callback(err);\n            }\n            executeView(result[\"app name\"]);\n          });\n        });\n      } else {\n        executeView(pkg);\n      }\n    });\n  } else {\n    executeView(name);\n  }\n\n};\n\n//\n// Usage for `jitsu apps view [<name>]`\n//\napps.view.usage = [\n  'Lists the information for the application in the current',\n  'directory. If <name> is supplied then that application',\n  'is listed instead.',\n  '',\n  'jitsu apps view',\n  'jitsu apps view <name>'\n];\n\n//\n// ### function list (callback)\n// #### @name {string} **optional** Name of the application to create\n// #### @callback {function} Continuation to pass control to when complete.\n// Lists the applications for the authenticated user.\n//\napps.update = function (name, callback) {\n\n//\n  // Allows arbitrary amount of arguments\n  //\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    name = args[0] || null;\n  }\n\n  jitsu.log.silly('Reading package.json in ' + process.cwd());\n  jitsu.package.tryRead(process.cwd(), callback, function (pkg) {\n    name = name || pkg.name;\n\n    jitsu.apps.view(name, function (err, app) {\n      if (err) {\n        return callback(err);\n      }\n\n      var diff = jitsu.common.objectDiff(app, pkg);\n      if (!diff) {\n        jitsu.log.warn('No changes found in package.json for ' + name.magenta);\n        return callback();\n      }\n\n      jitsu.log.info('Updating application ' + name.magenta + ' with:');\n      jitsu.inspect.putObject(diff);\n\n      jitsu.apps.update(name, diff, callback);\n    });\n  });\n};\n\n//\n// Usage for `jitsu apps update [<name>]`\n//\napps.update.usage = [\n  'Updates the application in the current directory',\n  'with the information in the package.json file. If',\n  '<name> is supplied the application with <name> is updated.',\n  '',\n  'jitsu apps update',\n  'jitsu apps update <name>'\n];\n\n//\n// ### function destroy (callback)\n// #### @name {string} **optional** Name of the application to destroy.\n// #### @callback {function} Continuation to pass control to when complete.\n// Destroys the application specified by `name`. If no name is supplied\n// this will destroy the application in the current directory.\n//\napps.destroy = function (name, callback) {\n\n  //\n  // Allows arbitrary amount of arguments\n  //\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    name = args[0] || null;\n  }\n  if (!name) {\n    jitsu.package.tryRead(process.cwd(), callback, function (pkg) {\n      jitsu.log.info('Attempting to destroy app ' + pkg.name.magenta);\n      name = pkg.name;\n      executeDestroy();\n    });\n  } else {\n    executeDestroy();\n  }\n\n  function executeDestroy() {\n    jitsu.log.info('Destroy app ' + name.magenta);\n    jitsu.prompt.confirm('yes/no', { default: 'yes'}, function(err, result){\n      if (result) {\n        jitsu.apps.destroy(name, function (err) {\n          jitsu.log.silly('Done destroying app ' + name.magenta);\n          return err ? callback(err) : callback();\n        });\n      } else {\n        jitsu.log.info('app ' + name.magenta + ' was not destroyed');\n        callback(null);\n      }\n    });\n  }\n};\n\n//\n// Usage for `jitsu apps destroy [<name>]`\n//\napps.destroy.usage = [\n  'Destroys the application in the current directory. If',\n  '<name> is supplied then that application is destroyed instead',\n  '',\n  'jitsu apps destroy',\n  'jitsu apps destroy <name>'\n];\n\n//\n// ### function start (callback)\n// #### @name {string} **optional** Name of the application to start.\n// #### @callback {function} Continuation to pass control to when complete.\n// Starts the application specified by `name`. If no name is supplied\n// this will start the application in the current directory.\n//\napps.start = function (name, cloud, callback) {\n\n  //\n  // Allows arbitrary amount of arguments\n  //\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    name = args[0] || null;\n    cloud = args[1] || null;\n  }\n\n  // Little check when call jitsu start directly\n  if (typeof cloud === 'string') {\n    cloud = { provider: cloud };\n    if (args[2]) {\n      cloud.datacenter = args[2];\n    } else {\n      jitsu.log.error('Error: No datacenter name specified');\n      jitsu.log.error('Please use a valid datacenter name.');\n      return callback(new Error(), true)\n    }\n  }\n\n  function executeStart() {\n    // Skip straight to cloud if we have cloud data.\n    if (cloud) return apps.cloud(name, cloud.provider, cloud.datacenter, callback);\n\n    jitsu.log.info('Starting app ' + name.magenta);\n\n    var showInfo = function showInfo (err, config) {\n      if (err) {\n        return handleStartError(err, name, callback);\n      }\n\n      async.series({\n        //\n        // 1. Fetch the endpoints so that we can properly\n        //    tell the user what datacenter they are in later.\n        //\n        endpoints: function getEndpoints(next) {\n          jitsu.apps.endpoints(next);\n        },\n        //\n        // 2. Get app information to show the proper subdomain.\n        //\n        app: function start(next) {\n          jitsu.apps.view(name, next);\n        }\n      }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n\n        var endpoints = result.endpoints,\n            tld = (config && config.provider && config.datacenter)\n              ? result.endpoints[config.provider][config.datacenter]\n              : 'api.jit.su',\n            subdomain = result.app.subdomain;\n\n        jitsu.log.info('App ' + name.magenta + ' is now started');\n        jitsu.log.info(('http://' + subdomain + tld.replace('api', '')).magenta + ' on Port ' + '80'.magenta);\n        callback();\n      });\n    }\n\n    return jitsu.apps.start(name, showInfo);\n  }\n\n  if (!name) {\n    return jitsu.package.tryRead(process.cwd(), callback, function (pkg) {\n      name = pkg.name;\n      executeStart();\n    });\n  } else {\n    executeStart();\n  }\n\n};\n\n//\n// Usage for `jitsu apps start [<name>]`\n//\napps.start.usage = [\n  'Starts the application in the current directory. If <name>',\n  'is supplied then that application is started instead.',\n  '',\n  'jitsu apps start',\n  'jitsu apps start <name>'\n];\n\n//\n// ### function restart (name, callback)\n// #### @name {string} **optional** Name of the application to restart.\n// #### @callback {function} Continuation to pass control to when complete.\n// Restarts the application specified by `name`. If no name is supplied\n// this will restart the application in the current directory.\n//\napps.restart = function (name, callback) {\n\n  //\n  // Allows arbitrary amount of arguments\n  //\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    name = args[0] || null;\n  }\n\n  function executeRestart() {\n    jitsu.log.info('Restarting app ' + name.magenta);\n    jitsu.apps.restart(name, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      jitsu.log.info('App ' + name.magenta + ' has been restarted');\n      callback();\n    });\n  }\n\n  if (!name) {\n    return jitsu.package.tryRead(process.cwd(), callback, function (pkg) {\n      name = pkg.name;\n      executeRestart();\n    });\n  }\n\n  executeRestart();\n};\n\n//\n// Usage for `jitsu apps restart [<name>]`\n//\napps.restart.usage = [\n  'Restarts the application in the current directory. If <name>',\n  'is supplied then that application is restarted instead.',\n  '',\n  'jitsu apps restart',\n  'jitsu apps restart <name>'\n];\n\n//\n// ### function stop (callback)\n// #### @name {string} **optional** Name of the application to stop.\n// #### @callback {function} Continuation to pass control to when complete.\n// Stops the application specified by `name`. If no name is supplied\n// this will stop the application in the current directory.\n//\napps.stop = function (name, callback) {\n\n  //\n  // Allows arbitrary amount of arguments\n  //\n  if (arguments.length) {\n    var args = utile.args(arguments);\n    callback = args.callback;\n    name = args[0] || null;\n  }\n\n  function executeStop() {\n    jitsu.log.info('Stopping app ' + name.magenta);\n    jitsu.apps.stop(name, function (err) {\n\n      //\n      // TODO: replace this error handling with errs library\n      //\n      if (err) {\n        if (err.result && err.result.error === \"not_found\") {\n          jitsu.log.error('App ' + name.magenta + ' doesn\\'t exist on Nodejitsu yet!');\n          return callback({});\n        }\n        return callback(err);\n      }\n\n      jitsu.log.info('App ' + name.magenta + ' is now stopped');\n      callback();\n    });\n  }\n\n  if (!name) {\n    return jitsu.package.tryRead(process.cwd(), callback, function (pkg) {\n      name = pkg.name;\n      executeStop();\n    });\n  }\n\n  executeStop();\n};\n\n//\n// Usage for `jitsu apps stop [<name>]`\n//\napps.stop.usage = [\n  'Stops the application in the current directory. If <name>',\n  'is supplied then that application is stopped instead.',\n  '',\n  'jitsu apps stop',\n  'jitsu apps stop <name>'\n];\n\n//\n// ### function setdrones (name, number, callback)\n// #### @name {string} **optional** Name of the application to stop.\n// #### @callback {function} Continuation to pass control to when complete.\n// Stops the application specified by `name`. If no name is supplied\n// this will stop the application in the current directory.\n//\napps.setdrones = function (name, number, callback) {\n  function executeSet() {\n    number = parseInt(number, 10);\n\n    jitsu.log.info('Setting number of drones for app ' + name.magenta + ' to ' + number.toString().magenta);\n    jitsu.apps.setDrones(name, number, function (err) {\n      if (err) {\n        return handleStartError(err, name, callback);\n      }\n\n      jitsu.log.info('App ' + name.magenta + ' is now running on ' + number.toString().magenta + ' drones');\n      callback();\n    });\n  }\n\n  if (!isNaN(parseInt(name, 10))) {\n    number = name;\n    name = null;\n  }\n\n  if (!name) {\n    return jitsu.package.tryRead(process.cwd(), callback, function (pkg) {\n      name = pkg.name;\n      executeSet();\n    });\n  }\n\n  executeSet();\n};\n\n//\n// Usage for `jitsu apps setdrones [<name>] <number>`\n//\napps.setdrones.usage = [\n  'Sets number of drones used by the application.',\n  '',\n  'jitsu apps setdrones [<name>] <number>',\n];\n\n\n//\n// ### function cloud (name, provider, datacenter, drones, callback)\n// #### @name {string} **optional** Name of the application to view/set cloud info for.\n// #### @callback {function} Continuation to pass control to when complete.\n// Views or sets the cloud information for the specified application defaulting\n// to the app in the current directory.\n//\napps.cloud = function (name, provider, datacenter) {\n  var providers = ['joyent'],\n      args      = utile.args(arguments),\n      callback  = args.callback,\n      drones    = jitsu.argv.drones,\n      ram       = jitsu.argv.ram;\n\n  //\n  // If `name` is `list` then show the current providers.\n  //\n  if (name === 'list') {\n    return jitsu.apps.endpoints(function (err, endpoints) {\n      if (err) {\n        callback(err);\n      }\n\n      if (typeof endpoints === 'undefined') {\n        endpoints = {};\n      }\n\n      jitsu.log.info('You can use one of the following providers');\n      Object.keys(endpoints).forEach(function (provider) {\n        var datacenters = endpoints[provider];\n        Object.keys(datacenters).forEach(function (datacenter) {\n          jitsu.log.data('jitsu cloud ' + provider + ' ' + datacenter);\n        });\n      });\n\n      callback(null);\n    });\n  }\n\n  //\n  // If `name` is one of the known providers then curry\n  // arguments and read package.json from `process.cwd()`.\n  //\n  if (providers.indexOf(name) !== -1) {\n    datacenter = provider;\n    provider = name;\n    name = null;\n  }\n\n  //\n  // If `datacenter` was not passed it will\n  // be the callback.\n  //\n  datacenter = typeof datacenter !== 'function'\n    ? datacenter\n    : null;\n\n  //\n  // Print the cloud information for the app and respond.\n  //\n  function viewCloud(app) {\n    if (!app.config || !app.config.cloud) {\n      jitsu.log.error('Error: The app ' + app.name.magenta + ' don\\'t have any cloud config.');\n      jitsu.log.error('You need deploy your app before get any cloud config.');\n      return callback(new Error());\n    }\n    jitsu.log.info('Viewing cloud info for ' + name.magenta);\n    jitsu.inspect.putObject(app.config.cloud[0]);\n    callback(null, app);\n  }\n\n  //\n  // 1. Print what cloud app is deployed in now.\n  // 2. Print new cloud app will be deployed to.\n  // 3. Start the app in the specified cloud.\n  //\n  function setCloud(app) {\n    drones = drones || app.maxDrones;\n    ram = ram || (app.config.cloud ? app.config.cloud[0].ram : 256);\n\n    var cloud = {\n      datacenter: datacenter,\n      provider: provider,\n      drones: drones,\n      ram: ram\n    };\n\n    if (app.state === 'started') {\n      jitsu.log.info('App currently deployed to the cloud with:')\n      jitsu.inspect.putObject(app.config.cloud[0]);\n    }\n\n    jitsu.log.info('Deploying application to the cloud with:')\n    jitsu.inspect.putObject(cloud);\n\n    async.series({\n      //\n      // 1. Fetch the endpoints so that we can properly\n      //    tell the user what datacenter they are in later.\n      //\n      endpoints: function getEndpoints(next) {\n        jitsu.apps.endpoints(next);\n      },\n      //\n      // 2. Start the app with the specified cloud information.\n      //\n      start: function start(next) {\n        jitsu.apps.datacenter(name, cloud, next);\n      }\n    }, function (err, result) {\n      if (err) {\n        jitsu.log.error('Error starting ' + name.magenta);\n        return callback(err);\n      }\n\n      var endpoints = result.endpoints,\n          tld = result.endpoints[provider][datacenter];\n\n      jitsu.log.info('App ' + name.magenta + ' is now started');\n      jitsu.log.info(('http://' + app.subdomain + tld.replace('api', '')).magenta + ' on Port ' + '80'.magenta);\n      callback(null, app);\n    });\n  }\n\n  //\n  // Retreive the app and call `setCloud` or `viewCloud`\n  // depending on what arguments have been passed.\n  //\n  function viewApp() {\n    jitsu.log.info('Fetching app ' + name.magenta);\n    jitsu.apps.view(name, function (err, app) {\n      if (err) {\n        jitsu.log.error('App ' + name.magenta + ' doesn\\'t exist on Nodejitsu yet!');\n        jitsu.log.help('Try running ' + 'jitsu deploy'.magenta);\n        return callback({});\n      }\n\n      return provider && datacenter\n        ? setCloud(app)\n        : viewCloud(app);\n    });\n  }\n\n  //\n  // Read the app from the current directory.\n  //\n  function readApp(next) {\n    jitsu.package.read(process.cwd(), function (err, pkg) {\n      if (err) {\n        callback(err);\n      }\n\n      name = pkg.name;\n      next();\n    });\n  }\n\n  return !name\n    ? readApp(viewApp)\n    : viewApp();\n};\n\n//\n// Usage for `jitsu apps cloud`.\n//\napps.cloud.usage = [\n  'Views or sets the cloud information for the specified application defaulting',\n  'to the app in the current directory',\n  '',\n  'jitsu apps cloud [<name>]',\n  'jitsu cloud [<name>]',\n  '',\n  'jitsu apps cloud [<name>] <provider> <datacenter> [<drones>]',\n  'jitsu cloud [<name>] <provider> <datacenter> [<drones>]',\n  '',\n  'Options:',\n  '--ram  RAM size to deploy to'\n];\n\n//\n// ### function browse (name, callback)\n// #### @name {string} Application name (optional).\n// #### @callback {function} Continuation to respond to.\n// Open app in a browser.\n//\napps.browse = function (name, callback) {\n  function runBrowser(err, pkg) {\n    if (err) {\n      return callback(err);\n    }\n\n    opener('https://' + (pkg.domain || (pkg.domains && pkg.domains[0]) || (pkg.subdomain + '.jit.su')));\n    callback();\n  }\n\n  if (!name) {\n    return jitsu['package'].tryRead(process.cwd(), runBrowser, function (pkg) {\n      runBrowser(null, pkg);\n    });\n  }\n\n  jitsu.apps.view(name, runBrowser);\n};\n\n//\n// Usage for `jitsu apps browse`.\n//\napps.browse.usage = [\n  'Open application in a browser.',\n  '',\n  'jitsu apps browse [<name>]'\n];\n"}